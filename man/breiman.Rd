% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/postestimation.R
\name{breiman}
\alias{breiman}
\title{Estimates parameter-wise shrinkage factors using Breiman (1995) method}
\usage{
breiman(
  x,
  y,
  varx = NULL,
  lambda = NULL,
  nfolds = 10,
  foldid = NULL,
  nlambda = 100,
  beta.initial = NULL,
  lambda.initial = NULL,
  initial.estimates = c("default", "ridge", "lasso"),
  lambda.min.ratio = 1e-08,
  type.measure = c("mse", "mae"),
  lower.limits = 0,
  upper.limits = Inf,
  standardize = FALSE,
  standardize.response = FALSE
)
}
\arguments{
\item{x}{A standardized matrix of predictors of dimension nobs x nvars, where 
each row is an observation vector.If not standardized, set standardize to TRUE.}

\item{y}{A numeric centered quantitative vector of response. If not centered,
set `standardize` to TRUE; this will standardize x but center y. See `standardize.response` 
for more details.}

\item{varx}{Variables selected by a selection procedure. The default value 
is NULL, and all column names of \code{x} are used.}

\item{lambda}{Optional vector of tuning parameter. Default is NULL and 
the program will generate its sequence}

\item{nfolds}{Number of folds - default is 10. If k = n then k-fold is equal to
leave-one-out cv.}

\item{foldid}{A vector of values between 1 and nfolds identifying what fold
each observation is in while conducting cross-validation. Default is NULL
and the program will generate it.}

\item{nlambda}{The number of lambda values; default is 100}

\item{beta.initial}{A vector of initial estimates obtained from standardized 
predictor matrix x. The default value is \code{beta.initial = NULL}, and the 
program will estimate them based on the chosen `initial.estimate` and 
`lambda.initial`. If supplied, the number of nonzero elements must be at least 2.}

\item{lambda.initial}{The tuning parameter for the initial estimates using
lasso or ridge regularization. If a vector of lambdas are provided, the
optimal lambda for initial estimates will be returned.}

\item{initial.estimates}{Specifies the type of initial estimates to use for
constructing weights. The \code{initial.estimates = "default"}
option uses \code{"OLS"} estimates. Other options include 
\code{initial.estimates ="ridge"} or \code{initial.estimates ="lasso"} 
estimates, which are calculated using the user-supplied \code{`lambda.initial`.}}

\item{lambda.min.ratio}{lambda can be provided if the user wants to specify 
the lambda sequence, but typical usage is for the program to construct the 
lambda sequence on its own. When automatically generated, the lambda sequence
is determined by lambda.max and lambda.min.ratio. The latter is the ratio of
smallest value of the generated lambda sequence (say lambda.min) to lambda.max.
The program generates nlambda values linear on the log scale from lambda.max 
down to lambda.min. lambda.max is not user-specified but is computed from the
input x and y: it is the smallest value for lambda such that all the 
coefficients are zero. Default is lambda.min.ratio = 0.00000001}

\item{type.measure}{Loss function to use for cross-validation. Currently, 
two options are available. The default option is \code{type.measure = "mse"},
which corresponds to squared error. Another option is \code{type.measure = "mae"}
(mean absolute error).}

\item{lower.limits}{Vector of lower limits for each shrinkage factor. 
The default is 0, and nonnegative shrinkage factors will be estimated.}

\item{upper.limits}{Vector of upper limits for the shrinkage factors. 
The default is Inf, and unbounded shrinkage factors will be estimated.}

\item{standardize}{Specifies whether to standardize the predictors matrix 
\code{`x`} to have mean 0 and unit variance. If set to TRUE, \code{`x`} will be
standardized. Additionally, the response variable \code{`y`} will be centered
by subtracting its mean. This standardization step can be useful to ensure 
that the predictors are on a comparable scale. By default, 
\code{standardize = FALSE}, indicating that no standardization will be performed.
This assumes that users have already standardized x and centered y so that the intercept
is zero.}

\item{standardize.response}{Specifies whether the response variable y should be 
standardized to have unit variance. This option divides \code{`y`} by its standard
deviation.}
}
\value{
Returns a list with the following components:
\item{ShrunkenRegCoef}{Estimated shrunken coefficients}
\item{nvar}{The number of variables selected}
\item{shrinkagefactors}{ Shrinkage factors for the selected variables}
\item{x}{Design matrix of the selected variables}
}
\description{
This method uses a quadratic penalty term on the shrinkage factors
(Breiman 1995). The original approach did not impose non-negativity constraints on 
the shrinkage factors. In this implementation, both options are available through
the "lower.limits" parameter.
}
